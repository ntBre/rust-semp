# -*- org-todo-keyword-faces: (("CHECKPOINT" . "blue") ("WAIT" . "#fce803")); -*-
#+TODO: TODO WAIT | DONE
#+TODO: | CHECKPOINT

* Timings
  these are real times collected using the =time= recipe in the Makefile
  | Commit  | T_full    | Peak Mem |
  |---------+-----------+----------|
  | b7565eb | 2m26.295s |          |
  | de7888e | 2m26.897s |          |
  | 1209365 | 2m25.366s |          |
  | 130766f | 2m20.006s | 1.6MB    |
  | a5cd573 | 2m24.663s | 565.2kB  |
  |         | 2m22.688s | 414.6kB  |

* Notes
  this time write input as needed, not all at once. the first three all need to
  be inside of the 'as needed' part -> iterator returning jobs?
  - if I can set up a list of structs containing all the info necessary for a
    job, I can map over that and submit as I go
  - use Iter.take(n) to grab the first n, I guess you slice off the front n
    elements of the original slice after that

  see [[https://msfjarvis.dev/posts/building-static-rust-binaries-for-linux/][this]] if I have trouble with static binaries

* tasks
** DONE load geometries
** DONE write .mop input files
** DONE write param file
** DONE write submission scripts
** DONE process MOPAC output
** DONE submit submission scripts
   - need real submission and also test implementation
   - both in place but both need to be tested
** DONE run mopac
   - assemble jobs and run them
** DONE build, run, poll loop
   - take a list of jobs to run and build, run, poll, and clean them
     - for faster calculations (eg the NumJac) just send it more built jobs to
       run at once
   - each piece is ready, just need the loop connecting them
     - probably also factor out the pieces
** DONE clean up after above as stuff finishes
   - partly in place, at least with the struct fields. just need to actually set
     up the structure to do the deleting and call it
** CHECKPOINT above are the essentials
** DONE assemble Jacobian matrix
   build_jobs needs to take a dst argument that's a slice of f64 as well as a
   starting index, and a coefficient.
   - doesn't actually need to take =dst=, only drain needs to take dst
   - would be nice to connect dst to the indices somehow
   - for current use
     - dst is the size of moles
     - starting index is always 0
     - coefficient is always 1
   - for numjac
     - dst will be the size of moles × params
     - starting index will depend on the "column"" I'm doing
       - I'll compute jacᵀ so that each "column" will really be a row and be
         adjacent in one big slice
     - coefficient for forward is 1/2Δ and for back is –1/2Δ

   - probably need the count in build_jobs to be a static so it can increase
     across calls, otherwise could get name collisions when building one part of
     jacobian at a time
     - same with chunk_num in drain
   - how to build jacobian at one time? right now drain points into one
     destination generated by build_chunk
   - let's make dst an argument and give each index a coeff so in the front/back
     parts of numjac I can just use that
** DONE load energies
** TODO set up levmar problem and do matrix math
** TODO implement levmar - cases, lambda stuff, and iteration
** TODO Broyden
** CHECKPOINT below are niceties
** TODO read config file

* basic job-running outline
** generate list of Mopacs
** as needed, turn mopacs into jobs
   - write input file
   - write param file
   - write submission script
   - the last two of these need to be chunked and chunked separately
     - only need to write a new param file when the parameters change
       - share it across forward/back of numjac and across a run of single
         semi-empirical vector run
     - write a new submission script per chunksize jobs
** submit these jobs
** poll finishing jobs and extract energies
** delete finished jobs
   - mop, out, aux, arc
   - param file - when shared jobs done
   - pbs file - when different set of shared jobs done

* running jobs brainstorming
  - the basic operation is run a set of jobs with a single set of parameters
    1. this covers one SE step - f(β)
    2. also covers NumJac - one set of parameters for each front/back per column,
       but then you have to wait for each front/back to finish before you run
       another
  - the reason I want to mix parameters is because of point 2 above - I want to
    be able to pull from the whole Jacobian at one time instead of switching
    from running to writing over and over
    - [X] just go back to one param file per job
  - [X] I think a Job type needs to contain
    1. a Mopac - all the information for setting up the mopac job
       - set when I first generate the jobs
    2. a submit_script - the PBS file for the chunk it's in
       - set when I write the jobs to disk
    3. a job_id - the jobid for the chunk it's in
       - set when the job is submitted
  - cleanup
    - delete Job.mopac.filename.{mop,out,aux,arc} and Job.mopac.paramfile when a
      single job finishes
    - delete Job.submit_script when all the jobs in a chunk finish
      - have to keep track of the jobs belonging to a chunk

* Data
  current output:
  Iter        Norm       ΔNorm        RMSD       ΔRMSD         Max        Time
  0    828.6919    828.6919    165.7384    165.7384    266.6057         0.0
  1    325.2037   -503.4882     65.0407   -100.6976    126.9844        40.1

  after scaling:
  1    389.9481   -438.7438     77.9896    -87.7488    201.6500        34.2

  after fixing bounds and <= 5:
  1     70.7093   -757.9826     14.1419   -151.5965     27.7492        29.3
  2     28.7168    -41.9925      5.7434     -8.3985      8.0413        29.7
  3     22.7316     -5.9852      4.5463     -1.1970      7.0542        29.8
  4     22.8138      0.0823      4.5628      0.0165      6.2959        29.7
  5     21.3078     -1.5061      4.2616     -0.3012      6.1055        30.6

  this is weirdly better than the Go version, not sure it should be

  after rest of lev mar:
  1     70.5271   -758.1648     14.1054   -151.6330     27.1241        28.2
  2     27.8114    -42.7157      5.5623     -8.5431      9.7420        29.2
  3     21.9563     -5.8551      4.3913     -1.1710      7.0847        31.8
  4     19.8039     -2.1523      3.9608     -0.4305      5.4642        30.5
  5     19.1505     -0.6535      3.8301     -0.1307      5.3263        30.6

  after broyden:
  1     70.5271   -758.1648     14.1054   -151.6330     27.1241        26.7
  2     66.8706     -3.6565     13.3741     -0.7313     29.8608         1.5
  3     55.3589    -11.5117     11.0718     -2.3023     23.5758         4.3
  4    246.9214    191.5625     49.3843     38.3125     97.3837        12.5
  5     16.1347   -230.7867      3.2269    -46.1573      9.2995         0.9

  absolutely disastrous 4th iteration, but it recovers very nicely on the 5th,
  and it does all four of its iterations faster than one more numerical
  Jacobian so I guess it's worth it

  also converges on iteration 8 after another num_jac on 6, so I'd say it's
  working well

  6     15.9826     -0.1521      3.1965     -0.0304      9.2602        34.9
  7     14.2220     -1.7606      2.8444     -0.3521      5.4632         0.8
  8     14.2220     -0.0000      2.8444     -0.0000      5.4632         9.2

  after giving up on broyden for a bad step:
  1     70.5271   -758.1648     14.1054   -151.6330     27.1241        27.8
  2     66.8706     -3.6565     13.3741     -0.7313     29.8608         1.8
  3     55.3589    -11.5117     11.0718     -2.3023     23.5758         4.4
  4     36.8949    -18.4640      7.3790     -3.6928     20.8954        25.2
  5     27.9356     -8.9593      5.5871     -1.7919     11.5313         0.8

  gets rid of disastrous 4th iteration, obviously doesnt go down as far on 5,
  but it converges to a norm of ~11 after a couple more iterations
